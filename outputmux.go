// dcc - dependency-driven C/C++ compiler front end
//
// Copyright Â© A.Newman 2015.
//
// This source code is released under version 2 of the  GNU Public License.
// See the file LICENSE for details.
//

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

// OutputMux is an io.Writer multiplexor used to ensure output from
// each Writer is NOT interleaved when written to a single output.
//
// The OutputMux NewWriter method returns an io.WriteCloser that lets
// it user write via the OutputMux. Any output is cached until the
// writer is closed at which time the OutputMux flushes the data to
// its output Writer. Presently there is no limit to the amount of
// data buffered by the output mux, this should only be a concern when
// using C++ (that's a joke...template errors).
//
type OutputMux struct {
	w    io.Writer         // output
	mux  chan outputMuxMsg // input
	stop chan struct{}     // stop
}

// The io.Writer that talks to an OutputMux is the write-side of an
// os.Pipe.  the read-side of the pipe is read by a separate goroutine
// that transfers lines of text read from the pipe to the central
// multiplexor. Lines are transferred as outputMuxMsg structures.
//
type outputMuxMsg struct {
	source io.Reader
	text   string
	eof    bool
}

// NewOutputMux returns a new OutputMux that will write
// its output to the given io.Writer.
//
func NewOutputMux(w io.Writer) *OutputMux {
	mux := &OutputMux{
		w:    w,
		mux:  make(chan outputMuxMsg, 100),
		stop: make(chan struct{}),
	}
	go mux.run()
	return mux
}

// run runs the receiver's input processing loop, reading and buffering
// output generated by its io.WriteCloser clients and flushing that
// output when the client is closed.
//
func (om *OutputMux) run() {
	// Each Reader goroutine (and its corresponding Writer) has an
	// slice of strings that acts as a buffer for its output. We
	// don't expect too much output (although the C++ template
	// driven errors can be quite long).
	//
	buffers := make(map[io.Reader][]string)

	flush := func(r io.Reader) {
		for _, s := range buffers[r] {
			fmt.Fprintln(om.w, s)
		}
		buffers[r] = nil
	}

	flushall := func() {
		for r := range buffers {
			flush(r)
		}
	}

	for {
		select {
		case <-om.stop:
			flushall()
			om.stop <- struct{}{}
			return

		case msg := <-om.mux:
			if msg.eof {
				flush(msg.source)
			} else {
				if _, ok := buffers[msg.source]; !ok {
					buffers[msg.source] = make([]string, 0)
				}
				buffers[msg.source] = append(buffers[msg.source], msg.text)
			}
		}
	}
}

// NewWriter returns an io.Writer used to send data to the receiver
// for eventual output.
//
func (om *OutputMux) NewWriter() *os.File {
	r, w, err := os.Pipe()
	if err != nil {
		panic(err)
	}
	go func(r io.Reader) {
		in := bufio.NewScanner(r)
		for in.Scan() {
			om.mux <- outputMuxMsg{r, in.Text(), false}
		}
		om.mux <- outputMuxMsg{r, "", true}
	}(r)
	return w
}

// Close closes the receiver, stopping any processing of clients and
// flushing any buffered output.
//
// Close sends a stop signal to the cause the receiver's Run method to
// stop processing and awaits the, ignored, response indicating
// processing has stopped.
//
func (om *OutputMux) Close() {
	om.stop <- struct{}{}
	<-om.stop
}
