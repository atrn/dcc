// dcc - dependency-driven C/C++ compiler front end
//
// Copyright Â© A.Newman 2015.
//
// This source code is released under version 2 of the  GNU Public License.
// See the file LICENSE for details.
//

package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
)

// OutputMux is an io.Writer multiplexor that is used to ensure output
// writtento multiple Writers is NOT interleaved when written to the
// final output writer.
//
// The OutputMux NewWriter method returns an io.WriteCloser that lets
// it user to write via the OutputMux. Data written to that
// WriteCloser is held in memory until its Close method is called at
// which time the buffered data is flushed to the OutputMux's output
// io.Writer. There is no limit to the amount of data held in an
// output mux io.Writer(Closer) but in this application that should
// not be an issue although C++ template errors can produce quite
// larges amounts of output.
//
type OutputMux struct {
	w    io.Writer         // output
	mux  chan outputMuxMsg // input
	stop chan struct{}     // stop
}

// The io.Writer that talks to an OutputMux is the write-side of an
// os.Pipe.  the read-side of the pipe is read by a separate goroutine
// that transfers lines of text read from the pipe to the central
// multiplexor. Lines are transferred as outputMuxMsg structures.
//
type outputMuxMsg struct {
	source io.Reader
	text   string
	eof    bool
}

// NewOutputMux returns a new OutputMux that will write
// its output to the given io.Writer.
//
func NewOutputMux(w io.Writer) *OutputMux {
	mux := &OutputMux{
		w:    w,
		mux:  make(chan outputMuxMsg, 100),
		stop: make(chan struct{}),
	}
	go mux.run()
	return mux
}

// run runs the receiver's input processing loop, reading and buffering
// output generated by its io.WriteCloser clients and flushing that
// output when the client is closed.
//
func (om *OutputMux) run() {
	// Each Reader goroutine (and its corresponding Writer) has an
	// slice of strings that acts as a buffer for its output. We
	// don't expect too much output (although the C++ template
	// driven errors can be quite long).
	//
	buffers := make(map[io.Reader][]string)

	flush := func(r io.Reader) {
		if slice, found := buffers[r]; found {
			for _, line := range slice {
				fmt.Fprintln(om.w, line)
			}
			buffers[r] = nil
		}
	}

	for {
		select {
		case <-om.stop:
			for b := range buffers {
				flush(b)
			}
			om.stop <- struct{}{}
			return

		case msg := <-om.mux:
			if msg.text != "" {
				if _, ok := buffers[msg.source]; !ok {
					buffers[msg.source] = make([]string, 0)
				}
				buffers[msg.source] = append(buffers[msg.source], msg.text)
			}
			if msg.eof {
				flush(msg.source)
			}
		}
	}
}

// NewWriter returns an io.Writer used to send data to the receiver
// for eventual output.
//
func (om *OutputMux) NewWriter() *os.File {
	r, w, err := os.Pipe()
	if err != nil {
		log.Panic(err)
	}
	go func(r io.Reader) {
		in := bufio.NewScanner(r)
		for in.Scan() {
			om.mux <- outputMuxMsg{r, in.Text(), false}
		}
		om.mux <- outputMuxMsg{r, "", true}
	}(r)
	return w
}

// Close closes the receiver, stopping any processing of clients and
// flushing any buffered output.
//
// Close sends a stop signal to the cause the receiver's run method to
// stop processing and awaits the, ignored, response indicating
// processing has stopped.
//
func (om *OutputMux) Close() {
	om.stop <- struct{}{}
	<-om.stop
}
