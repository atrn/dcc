# dcc - a dependency-driven C/C++ compiler driver

`dcc` is a C/C++ compiler driver _wrapper_ that sits atop some
underlying compiler - `gcc`, `clang`, or `icc` - and adds, parallel,
_dependency based builds_.

`dcc` works as a drop-in replacement for the underling compiler and
has it generate depedency information which `dcc` then uses, along
with hard-coded rules, to determine if compilation, or linking, is
actually required.

Like a `make`-based build `dcc` only compiles, or links, if an output
file is out-of-date with respect to its dependencies and needs to be
recreated.

`dcc` can be used as a _drop in_ replacement for `cc/c++(1)` however
the best `dcc` experience comes from relying more on its features. The
`dcc` implemented parallel builds are efficient, performing better
than similar tools (`make`, `ninja`) in my tests. And relying on `dcc`
for building removes the need for other tools (e.g. `make`) to do this
work and can considerably simplify build systems.


## using dcc

A typical use-case ia a small program or library, a _module_. The
module uses a `Makefile` with the usual sort of layout - define the
names of the output and the object files (relying upon make to infer
the names of the corresponding source files). Such a makefile will
typically rely on the inbuilt make _rules_ for building C/C++ code.

To use `dcc` with this sort of project we can simply set the `make`
`CC` or `CXX` macros to `dcc` and just use `dcc` as a drop-in
replacement for the compiler. In this situation `dcc` adds more
complete dependency checking to the build but will typically be
invoked to compile a single file at a time and the build won't get the
benefit of dcc's efficient parallel compilations.

Replacing the entire build rules, and any dependency management, and
letting dcc do the work is very easy. A Makefile using `dcc` can be
as simple as,

    myprogram :; dcc $(CFLAGS) file1.c file2.c file3.c -o myprogram

Because `dcc` does all the work of deciding what to compile we
do not have to do that in the makefile and can use it to _direct_
operations. `dcc` takes care of the compiling.

## dcc option processing

`dcc` works as a mostly drop-in replacement for cc(1) and similar
(gcc, g++, clang, clang++, icc, icpc, cl). Command line options are
passed to the underlying compiler and dcc adds options required to
have the compiler generate dependency information.

By default `dcc` stores dependencies in _.d_ files located alongside
the object files (i.e. in the same directoy).

## Depenencies

`dcc` uses dependency information generated by the compiler itself.
With gcc-style compilers this uses the `-MF` and `-MD` options to have
the compiler output make-format dependencies to a file. As a result
the dependencies are always up to date.

> It would be great if the dependencies were stored in the
> object file itself as a new type of section. This would
> make cleaning simpler. The compiler could get a new option,
> '-MO' to have store depedencies in the object file. This
> would replace the use of '-MF' to store them in a file.

Dcc removes the need for dependency management in other build tools
such as make(1). Using dcc in place of cc (gcc) in such tools removes
any need to manage object file dependencie and any associated
rules. This is simple as adding `CC = dcc`.

 A typical makefile can be reduced to a handful of lines,
e.g. the following is entirely sufficient for building a simple C
program,

    my-program :; dcc -Wall -O2 *.c -o $@
    clean :; dcc --clean *.o my-program

All real work is done by dcc, the makefile simply invokes it as it
would cc (this also works for C++ but C is used in the examples).  If
cc where used all .c files would be compiled every time and the
program linked. Using dcc all .c files are only compiled if required,
in parallel too, and the linker run only if required.

Note, we invoke dcc with all the source files unlike typical
make-driven cc usage. Dcc compiles multiple files in parallel (one
compiler per CPU for C++ and two for C).

Dcc behaves much like a simple make-driven build environment. And as
this behaviour is hard-coded it allows for greater efficiency in the
build. Dcc's concurrent builds are effecient because they are simple.

## Usage

Dcc acts as a drop-in replacement for cc(1) and c++(1), i.e. gcc or
clang or cl (or whichever cc-like compiler you are using).

dcc accepts any options understood by the underlying compiler,
collecting them and passing them on as required. dcc automatically
adds (or in the case of `cl.exe` _synthesizes_) _-MD_ and _-MF_
options to generate a dependency file which it reads on the next
run. Dependency files are stored in a `.dcc` directory alongside their
object file and are generally ignorable (dcc has a `--clean` mode to
have it remove such files).

dcc's behaviour, only compiling what  needs to be compiled, using alway
up  to date,  and correct, dependency  information allows  it to replace
the use  of  make(1)  and similar  build  tools for  managing compilation.
This vastly simplifies the  typical build system.  A single line command
is usually  sufficient to manage  the compuilation  of a typical library
or small program - _dcc $cflags *.c $libs_ replaces a typical small
Makefile used to build something. Add a _-c_ to only compile to objects.

dcc adds some features to regular cc (c++). In addition to knowing
how to link dcc _knows_ how to create static and dynamic libraries.
dcc's --lib option has it create a static library from the input
files or their corresponding object files. The --dll option has
dcc generate a dynamic library (a similar option to creating an
executable).

dcc also supports storing options in files. These files are read
and their modification times used to determine if files are out
of date. The files are named after the commonly used make macro
names. Compiler options are read from the files CFLAGS, or CXXFLAGS
if compiling C++, linker flags from the file LDFLAGS and library
options from the file LIBS.

Options files are searched for in the file system by traversing
up the directory hierarchy. This allows code in different directories
to share options. Files at one level can inherit settings from a
file higher in the directory hierarchy.

## Dependencies

Dcc uses  the compiler  generated dependency information  to determine
when object  files need to  be recreated and implements  similar rules
for linking, taking  into account both object files  and any libraries
(static or dynamic).

## Using dcc

Dcc is used in the same way as cc or c++ (or gcc/g++ etc...). You pass
it the  names of  files to  compiled and  various options  and library
names and so on. The source files  are compiled and, in the absence of
a  -c option,  the object  files linked  to form  an executable.   Dcc
accepts the  same options as  the underlying compiler,  simply passing
them on to it,  and for the most part dcc works  precisely in the same
manner  as the  real  compiler. What  is different  is  that dcc  only
compiles, or  links, if a target  object or executable file  is out of
date with  respect to the inputs.   This feature replaces most  of the
use of make(1) for compiling programs and libraries.

Dcc compiles a source file if one or more of the following is true,

- the object file does not exist
- the source file is newer than the object file
- compiler options have changed (see below)
- there is no dependency file for the object file
- a dependent file is newer than the object file
- the --force command-line option was supplied

Otherwise the source  file does  not require _re-compilation_.

In  the  same  way dcc only  invokes  the linker  or librarian if  the
output is out  of date with respect to its inputs.

## Differences to cc

Dcc  is mostly  identical in  use to  cc(1). Dcc  accepts a  number of
additional  options, -j,  --force  and --clean,  which it  interprets,
other options are passed on to the underlying compiler.

### Object files without -c

Dcc  behaves differently  to  cc in  the abscence  of  the -c  option.
Normally, without  -c, cc(1) will  compile the named source  files and
link the resultant objects to form  an executable file then remove the
object files.  Dcc does not remove  the object files. The object files
are  retained, and  dependency files  created, so  compilation may  be
avoided.

### Concurrent compilation

When dcc  does need to  compile source  files it does  so concurrently
using N concurrent jobs.  N defaults to the number of CPUs on the host
and can be  speciied using a -j  option in the same manner  as GNU and
BSD make programs.

## Compiler Options

Dcc provides  two methods  of defining compiler  options. They  can be
passed on the  command line as usual  or they can be stored  in a text
file  stored alongside  the  source code.   If a  file  to define  the
compiler options it becomes a dependency on the output so changing the
file, and  presumably the compiler options,  results in recompilation.
This  feature  is  handy  when  using  pre-compiled  header  files  or
non-standard compilation  options to ensure  that all files  are built
in the same way.

The name of the options file depends  on the language.  For C the file
_CFLAGS_ is  used, for C++ it  is _CXXFLAGS_.  Each file  has the same
format, one ore more lines of text containing options to the compiler.

Blank lines are ignored as are comment lines starting with a '#' other
than the special line '#inherit'. The '#inherit' directive must appear
alone on  a line and  causes dcc  to search for  a parent file  in the
directories  above the  current directory  with the  same name  as the
current file.  The options, or  libraries for LIBS files  (see below),
found  in the  inherited file  are inserted  at that  position in  the
options or libraries list. Modules that  are parts of systems use this
to  extend the  options or  libraries while  still using  the system's
standard settings.

## Libraries

The  file  LIBS can  be  used  to  define  the libraries  and  library
directories  used when  linking programs  and  DLLs. It  behaves in  a
similar manner to  the compiler options and executables  depend on the
file and relink when it changes.

Lines starting with  '-l' (elle) and '-L'  (capital-elle) are special.
Any library  name starting with '-l'  has the '-l' removed.  This lets
users use  UNIX linker-style  naming for familarity.  "Libraries" with
names  starting  with  '-L'   are  really  specifications  of  library
directories.

## Examples

### Applying dcc to an existing project - anici

The anici language interpreter is  a medium sized C program comprising
about 35,000 lines of code in about 70 source and 40 header files. The
code  is built  using some  Makefiles although  other systems  such as
ninja and scons have been used and  there are project file for IDEs on
MacOS  and Windows,  and  so on.  Compilation  is straightfoward.  The
source files are  compiled and then linked.  The resultant interpreter
it then used to create a file related to its installation.

Using make there are the usual macros defined with the desired
compiler options, files are named and a link command defined.  Then
there's the messing around with dependencies. We used to define them
manually for the major files. That didn't work properly of course
since people don't update them if they change so automatic
dependencies were used (via mkdep(1)). You only need to remember to
update the dependencies.

Converting to dcc is trivial. The Makefile is rewritten to use dcc
for compilation and linking, using it for all dependency management.
The entire Makefile becomes,

    SRCS= *.c macos/*.c pcre/*.c
    OBJS= $(SRCS:.c=.o)

    all:
        dcc -DNDEBUG -O2 -I. -Imacos $(SRCS) -o anici -lm

    clean:
        rm -rf anici $(OBJS) .dcc

Dcc ensures compilations always use up to date dependency information
while also only processing files when required. Make is only used to
orchestrate the overall build or perform _chores_.

## Simple Program

A typical "simple" program consists of a number of source files kept
in a single directory and using typical options when building.

Using dcc the "build system" is a one liner,

    $ dcc -O -Wall *.c -o myprogram -lz
    ... N compiles

If we repeat the command we see nothing compiled,

    $ !!
    dcc -O -Wall *.c -o myprogram -lz
    $

And if we touch one or more files we see only those files that depend
on them compiled,

    $ touch util.h
    dcc -O -Wall *.c -o myprogram -lz
    util.c
    main.c
    $

### Adding a Makefile

Typing a long dcc invocation all the  time is stupid. We could put the
command in a  one line shell script but a  typical user's PATH setting
means building requires some  command like, ./build.sh, which although
quite trivial  is annoying. It also  requires a sane VCS  that can set
the x  bit on the file  upon checkout otherwise developers  need to do
easily forgotten work.

Using  dcc as  CC  in makefiles  allows  us to  __not__  use make  for
dependency  checking  our  builds  but  to  orchestrate  higher  level
development actions.

## Implementation

Dcc  is  written in  Go  using  standard packages  and  a  copy of  an
unpublished package, atrn/log. The  atrn/log package is imported using
a relative file-system path so builds  may occur outside of a standard
Go workspace.

Dcc supports  various Linux distribtions,  the BSD's, MacOS  and other
POSIX systems  using gcc/clang. Microsoft cl support is underway.

Dcc mantains a dependency file for each source file and uses the
dependencies to determine if the source file requires compilation.  If
the resultant object file exists and is newer than any of the input
then it is __not__ compiled as there is no need to do so. The same
applies the any link step. The no -c switch is given the compiler
front-end, which is dcc in this case, links all the inputs to produce
some executable. Dcc applies dependency-based processing to this
situation and only links if any of the inputs are newer.

## License

Dcc is  released under  the GPL,  version 2. If  you advance  dcc, and
distribute, you must share the  advancements. The reasoning being that
a  utility such  as dcc  is infrastructure  and we  should share,  and
advance, infrastructure so we all get ahead.

Full license details are in the file LICENSE.
